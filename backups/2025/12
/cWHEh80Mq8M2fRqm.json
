{
  "active": false,
  "connections": {
    "Webhook Criar Cliente": {
      "main": [
        [
          {
            "node": "Validar Input Cliente",
            "type": "main",
            "index": 0
          },
          {
            "node": "Middleware Auth JWT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Middleware Auth JWT": {
      "main": [
        [
          {
            "node": "Validar Sessão Ativa",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Sessão Ativa": {
      "main": [
        [
          {
            "node": "Sessão Ativa?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sessão Ativa?": {
      "main": [
        [
          {
            "node": "Merge Auth Cliente",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Response Auth Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Input Cliente": {
      "main": [
        [
          {
            "node": "Input Cliente Válido?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Cliente Válido?": {
      "main": [
        [
          {
            "node": "Merge Auth Cliente",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response Validation Cliente Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Auth Cliente": {
      "main": [
        [
          {
            "node": "Preparar Dados Cliente",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preparar Dados Cliente": {
      "main": [
        [
          {
            "node": "Inserir Cliente",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Inserir Cliente": {
      "main": [
        [
          {
            "node": "Response Cliente Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Login": {
      "main": [
        [
          {
            "node": "Validar Input Login",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Input Login": {
      "main": [
        [
          {
            "node": "Input Válido?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Válido?": {
      "main": [
        [
          {
            "node": "Buscar Usuário",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response Validation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Usuário": {
      "main": [
        [
          {
            "node": "Usuário Existe?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Usuário Existe?": {
      "main": [
        [
          {
            "node": "Merge Dados Login",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Response Login Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Dados Login": {
      "main": [
        [
          {
            "node": "Validar Senha",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Senha": {
      "main": [
        [
          {
            "node": "Senha Válida?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Senha Válida?": {
      "main": [
        [
          {
            "node": "Gerar Tokens JWT",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response Login Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gerar Tokens JWT": {
      "main": [
        [
          {
            "node": "Criar Sessão",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Criar Sessão": {
      "main": [
        [
          {
            "node": "Log Auditoria Login",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Auditoria Login": {
      "main": [
        [
          {
            "node": "Response Login Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Refresh Token": {
      "main": [
        [
          {
            "node": "Validar Refresh Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Refresh Token": {
      "main": [
        [
          {
            "node": "Refresh Token Válido?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Refresh Token Válido?": {
      "main": [
        [
          {
            "node": "Verificar Sessão Refresh",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response Refresh Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verificar Sessão Refresh": {
      "main": [
        [
          {
            "node": "Sessão Refresh Válida?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sessão Refresh Válida?": {
      "main": [
        [
          {
            "node": "Gerar Novos Tokens",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response Refresh Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gerar Novos Tokens": {
      "main": [
        [
          {
            "node": "Atualizar Sessão",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Atualizar Sessão": {
      "main": [
        [
          {
            "node": "Response Refresh Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Logout": {
      "main": [
        [
          {
            "node": "Validar Token Logout",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Token Logout": {
      "main": [
        [
          {
            "node": "Token Logout Válido?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Token Logout Válido?": {
      "main": [
        [
          {
            "node": "Revogar Sessão",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response Logout Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Revogar Sessão": {
      "main": [
        [
          {
            "node": "Response Logout Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-12-29T15:18:45.244Z",
  "id": "cWHEh80Mq8M2fRqm",
  "isArchived": false,
  "meta": null,
  "name": "Backend-credGestor-FIXED",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// ============================================\n// MIDDLEWARE DE AUTENTICAÇÃO JWT - VERSÃO SEGURA\n// Valida assinatura, expiração e campos obrigatórios\n// ============================================\n\nconst crypto = require('crypto');\n\n// IMPORTANTE: Configure sua chave secreta nas variáveis de ambiente\nconst JWT_SECRET = process.env.JWT_SECRET || 'YOUR_SECRET_KEY_CHANGE_ME';\n\nif (JWT_SECRET === 'YOUR_SECRET_KEY_CHANGE_ME') {\n  console.warn('⚠️  ATENÇÃO: Configure JWT_SECRET nas variáveis de ambiente!');\n}\n\nfunction getAuthHeader(headers) {\n  if (!headers) return '';\n  return (\n    headers.authorization ||\n    headers.Authorization ||\n    headers.AUTHORIZATION ||\n    headers['x-authorization'] ||\n    headers['X-Authorization'] ||\n    ''\n  );\n}\n\nfunction base64UrlDecode(str) {\n  const pad = str.length % 4 === 0 ? '' : '='.repeat(4 - (str.length % 4));\n  const b64 = (str + pad).replace(/-/g, '+').replace(/_/g, '/');\n  return Buffer.from(b64, 'base64').toString('utf8');\n}\n\nfunction verifyJwtSignature(header, payload, signature, secret) {\n  const data = `${header}.${payload}`;\n  const expectedSignature = crypto\n    .createHmac('sha256', secret)\n    .update(data)\n    .digest('base64url');\n  \n  return signature === expectedSignature;\n}\n\nconst headers = $json.headers || {};\nconst authHeader = getAuthHeader(headers);\n\n// Validação 1: Header Authorization presente\nif (!authHeader || !authHeader.startsWith('Bearer ')) {\n  return [{ \n    json: { \n      autenticado: false, \n      erro: 'INVALID_TOKEN_FORMAT',\n      mensagem: 'Token não fornecido ou formato inválido. Use: Authorization: Bearer <token>'\n    } \n  }];\n}\n\nconst token = authHeader.slice(7).trim();\nconst parts = token.split('.');\n\n// Validação 2: JWT deve ter 3 partes (header.payload.signature)\nif (parts.length !== 3) {\n  return [{ \n    json: { \n      autenticado: false, \n      erro: 'INVALID_JWT_FORMAT',\n      mensagem: 'Token JWT mal formado'\n    } \n  }];\n}\n\nconst [headerB64, payloadB64, signatureB64] = parts;\n\n// Validação 3: Verificar assinatura do JWT\nif (!verifyJwtSignature(headerB64, payloadB64, signatureB64, JWT_SECRET)) {\n  return [{ \n    json: { \n      autenticado: false, \n      erro: 'INVALID_SIGNATURE',\n      mensagem: 'Assinatura do token inválida'\n    } \n  }];\n}\n\n// Decode do payload\nlet payload;\ntry {\n  payload = JSON.parse(base64UrlDecode(payloadB64));\n} catch (e) {\n  return [{ \n    json: { \n      autenticado: false, \n      erro: 'INVALID_JWT_PAYLOAD',\n      mensagem: 'Não foi possível decodificar o payload do token'\n    } \n  }];\n}\n\n// Validação 4: Token expirado\nif (payload.exp && payload.exp * 1000 < Date.now()) {\n  return [{ \n    json: { \n      autenticado: false, \n      erro: 'TOKEN_EXPIRED',\n      mensagem: 'Token expirado',\n      expirado_em: new Date(payload.exp * 1000).toISOString()\n    } \n  }];\n}\n\n// Validação 5: Token deve ser do tipo 'access'\nif (payload.type !== 'access') {\n  return [{ \n    json: { \n      autenticado: false, \n      erro: 'INVALID_TOKEN_TYPE',\n      mensagem: 'Token não é do tipo access',\n      tipo_recebido: payload.type\n    } \n  }];\n}\n\n// Validação 6: tenant_id obrigatório\nif (!payload.tenant_id) {\n  return [{ \n    json: { \n      autenticado: false, \n      erro: 'MISSING_TENANT_ID',\n      mensagem: 'Token não contém tenant_id'\n    } \n  }];\n}\n\n// Validação 7: user_id obrigatório\nif (!payload.sub) {\n  return [{ \n    json: { \n      autenticado: false, \n      erro: 'MISSING_USER_ID',\n      mensagem: 'Token não contém ID do usuário (sub)'\n    } \n  }];\n}\n\n// ✅ Token válido!\nreturn [{\n  json: {\n    autenticado: true,\n    usuario: {\n      id: payload.sub,\n      email: payload.email || null,\n      tenant_id: payload.tenant_id,\n      role: payload.role || 'user',\n    },\n    token_payload: payload,\n    validado_em: new Date().toISOString()\n  }\n}];\n"
      },
      "id": "9830f2dc-2cb2-4e80-b816-7442bd8ea346",
      "name": "Middleware Auth JWT",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Valida se o token está na sessão ativa e não foi revogado\nSELECT \n  us.id as session_id,\n  us.user_id,\n  us.tenant_id,\n  us.access_token,\n  us.refresh_token,\n  us.expires_at,\n  us.revogado,\n  us.created_at\nFROM public.user_sessions us\nWHERE us.user_id = $1::uuid\n  AND us.tenant_id = $2::uuid\n  AND us.revogado = false\n  AND us.expires_at > NOW()\nORDER BY us.created_at DESC\nLIMIT 1;",
        "options": {
          "queryReplacement": "={{ $json.usuario.id }}\n={{ $json.usuario.tenant_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        208,
        0
      ],
      "id": "ae93d80b-a8d5-4b61-8703-4c69f1eea737",
      "name": "Validar Sessão Ativa",
      "credentials": {
        "postgres": {
          "id": "ISeq8ovLtFz7Vb1t",
          "name": "Postgres CredGestor"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $items().length }}",
              "operation": "larger"
            }
          ]
        }
      },
      "id": "d3d4829a-d98d-493d-8124-8e93d06d3676",
      "name": "Sessão Ativa?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        416,
        0
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  erro: $('Middleware Auth JWT').item.json.erro || 'UNAUTHORIZED',\n  mensagem: $('Middleware Auth JWT').item.json.mensagem || 'Não autorizado',\n  timestamp: new Date().toISOString()\n} }}",
        "options": {}
      },
      "id": "bd777945-63cb-44f6-ba8f-084f0e9f4dfc",
      "name": "Response Auth Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        576,
        176
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "clientes",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "005b0a70-cd8f-439a-869e-6799b93e8ae6",
      "name": "Webhook Criar Cliente",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -208,
        80
      ],
      "webhookId": "criar-cliente"
    },
    {
      "parameters": {
        "jsCode": "const body = $json.body ?? {};\nconst errors = [];\n\nconst nome = body.nome_completo ?? body.name ?? body.nome;\nif (!nome || typeof nome !== 'string' || nome.trim().length < 3) {\n  errors.push('nome_completo é obrigatório e deve ter no mínimo 3 caracteres');\n}\n\nconst cpf = body.cpf;\nif (cpf) {\n  const cpfLimpo = String(cpf).replace(/\\D/g, '');\n  if (cpfLimpo.length !== 11) {\n    errors.push('cpf deve conter exatamente 11 dígitos');\n  }\n}\n\nreturn [{\n  json: {\n    valido: errors.length === 0,\n    erro: errors.length ? 'Validação falhou' : null,\n    detalhes: errors,\n    input: body,\n  }\n}];\n"
      },
      "id": "3207fc98-88bf-489b-82f7-d780c971b808",
      "name": "Validar Input Cliente",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -32,
        176
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.valido }}",
              "value2": true
            }
          ]
        }
      },
      "id": "5c3ec770-0b97-44c9-98dc-3face25471c7",
      "name": "Input Cliente Válido?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        192,
        160
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "593eebe6-7474-422d-b540-529e0b267ee2",
      "name": "Response Validation Cliente Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        368,
        320
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "7e2e7a1d-566a-4408-8e27-59a7acfd29e2",
      "name": "Merge Auth Cliente",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        704,
        48
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  sucesso: true,\n  mensagem: 'Cliente criado/atualizado com sucesso',\n  cliente: $json,\n  timestamp: new Date().toISOString()\n} }}",
        "options": {}
      },
      "id": "4254d721-5d39-42c9-9129-ced50d7b4d70",
      "name": "Response Cliente Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1376,
        48
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO public.clientes (\n  id,\n  tenant_id,\n  nome_completo,\n  cpf,\n  whatsapp,\n  email,\n  cep,\n  endereco,\n  complemento,\n  bairro,\n  cidade,\n  estado,\n  data_nascimento\n)\nVALUES (\n  gen_random_uuid(),\n  $1::uuid,  -- tenant_id OBRIGATÓRIO\n  $2,\n  $3,\n  $4,\n  $5,\n  $6,\n  $7,\n  $8,\n  $9,\n  $10,\n  $11,\n  $12\n)\nON CONFLICT (tenant_id, cpf)\nDO UPDATE SET\n  nome_completo   = EXCLUDED.nome_completo,\n  whatsapp        = EXCLUDED.whatsapp,\n  email           = EXCLUDED.email,\n  cep             = EXCLUDED.cep,\n  endereco        = EXCLUDED.endereco,\n  complemento     = EXCLUDED.complemento,\n  bairro          = EXCLUDED.bairro,\n  cidade          = EXCLUDED.cidade,\n  estado          = EXCLUDED.estado,\n  data_nascimento = EXCLUDED.data_nascimento,\n  updated_at      = NOW()\nRETURNING *;",
        "options": {
          "queryReplacement": "={{ $('Middleware Auth JWT').item.json.usuario.tenant_id }}\n={{ $json.nome_completo }}\n={{ $json.cpf }}\n={{ $json.whatsapp }}\n={{ $json.email }}\n={{ $json.cep }}\n={{ $json.endereco }}\n={{ $json.complemento }}\n={{ $json.bairro }}\n={{ $json.cidade }}\n={{ $json.estado }}\n={{ $json.data_nascimento }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1168,
        48
      ],
      "id": "1c387179-9f7d-4b89-979c-02146a34d4de",
      "name": "Inserir Cliente",
      "credentials": {
        "postgres": {
          "id": "ISeq8ovLtFz7Vb1t",
          "name": "Postgres CredGestor"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "a1",
              "name": "tenant_id",
              "value": "={{ $('Middleware Auth JWT').item.json.usuario.tenant_id }}",
              "type": "string"
            },
            {
              "id": "a2",
              "name": "nome_completo",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.nome_completo || $items('Webhook Criar Cliente')[0].json.body.nome || $items('Webhook Criar Cliente')[0].json.body.name }}",
              "type": "string"
            },
            {
              "id": "a3",
              "name": "cpf",
              "value": "={{ String($items('Webhook Criar Cliente')[0].json.body.cpf || '').replace(/\\D/g,'') }}",
              "type": "string"
            },
            {
              "id": "a4",
              "name": "whatsapp",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.whatsapp || null }}",
              "type": "string"
            },
            {
              "id": "a5",
              "name": "email",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.email || null }}",
              "type": "string"
            },
            {
              "id": "a6",
              "name": "cep",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.cep || null }}",
              "type": "string"
            },
            {
              "id": "a7",
              "name": "endereco",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.endereco || null }}",
              "type": "string"
            },
            {
              "id": "a8",
              "name": "complemento",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.complemento || null }}",
              "type": "string"
            },
            {
              "id": "a9",
              "name": "bairro",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.bairro || null }}",
              "type": "string"
            },
            {
              "id": "a10",
              "name": "cidade",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.cidade || null }}",
              "type": "string"
            },
            {
              "id": "a11",
              "name": "estado",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.estado || null }}",
              "type": "string"
            },
            {
              "id": "a12",
              "name": "data_nascimento",
              "value": "={{ $items('Webhook Criar Cliente')[0].json.body.data_nascimento || null }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        960,
        48
      ],
      "id": "e022ba97-13b8-47b4-823a-5a9f727546d3",
      "name": "Preparar Dados Cliente"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "auth/login",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "c4496f6f-a51d-40fe-9bf1-394abbfb2faa",
      "name": "Webhook Login",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -224,
        736
      ],
      "webhookId": "auth-login"
    },
    {
      "parameters": {
        "jsCode": "const body = $json.body ?? {};\nconst errors = [];\n\nif (!body.email || typeof body.email !== 'string' || !body.email.includes('@')) {\n  errors.push('email é obrigatório e deve ser válido');\n}\n\nif (!body.senha || typeof body.senha !== 'string' || body.senha.length < 6) {\n  errors.push('senha é obrigatória e deve ter no mínimo 6 caracteres');\n}\n\nreturn [{\n  json: {\n    valido: errors.length === 0,\n    erro: errors.length ? 'Validação falhou' : null,\n    detalhes: errors,\n    input: {\n      email: body.email,\n      senha_fornecida: !!body.senha\n    }\n  }\n}];\n"
      },
      "id": "982e58c0-a332-4cb0-a7cd-617bf0045d2b",
      "name": "Validar Input Login",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -16,
        736
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.valido }}",
              "value2": true
            }
          ]
        }
      },
      "id": "a345fc70-4d36-45fb-b427-7a61d1121bce",
      "name": "Input Válido?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        192,
        736
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "c07d8dfc-ede1-4faf-b5ce-f183c57ae75b",
      "name": "Response Validation Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        400,
        896
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  tu.id,\n  tu.tenant_id,\n  tu.email,\n  tu.senha_hash,\n  tu.role,\n  tu.ativo,\n  t.nome as tenant_nome\nFROM public.tenant_users tu\nINNER JOIN public.tenants t ON t.id = tu.tenant_id\nWHERE tu.email = $1\n  AND tu.ativo = true\nLIMIT 1;",
        "options": {
          "queryReplacement": "={{ $items('Webhook Login')[0].json.body.email }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        400,
        656
      ],
      "id": "b7408308-005f-4084-b8bb-7fb1476c60bb",
      "name": "Buscar Usuário",
      "credentials": {
        "postgres": {
          "id": "ISeq8ovLtFz7Vb1t",
          "name": "Postgres CredGestor"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $items().length }}",
              "operation": "larger"
            }
          ]
        }
      },
      "id": "b6e641ed-90d6-44f7-8ef6-f1fd29d9c0ef",
      "name": "Usuário Existe?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        608,
        656
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  erro: 'CREDENCIAIS_INVALIDAS',\n  mensagem: 'Email ou senha incorretos',\n  timestamp: new Date().toISOString()\n} }}",
        "options": {}
      },
      "id": "e1a518cf-8c9a-47cf-8615-a2005b3c7cf4",
      "name": "Response Login Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        816,
        816
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "99f88a9c-5aee-421e-9264-2095bcc5e3c4",
      "name": "Merge Dados Login",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        816,
        576
      ]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// VALIDAÇÃO DE SENHA COM BCRYPT\n// ============================================\n\nconst bcrypt = require('bcrypt');\n\nconst senhaFornecida = $items('Webhook Login')[0].json.body.senha;\nconst senhaHash = $json.senha_hash;\n\nif (!senhaHash) {\n  return [{\n    json: {\n      autenticado: false,\n      erro: 'SENHA_NAO_CONFIGURADA',\n      mensagem: 'Usuário não possui senha configurada'\n    }\n  }];\n}\n\ntry {\n  const senhaValida = await bcrypt.compare(senhaFornecida, senhaHash);\n  \n  if (!senhaValida) {\n    return [{\n      json: {\n        autenticado: false,\n        erro: 'SENHA_INVALIDA',\n        mensagem: 'Senha incorreta'\n      }\n    }];\n  }\n  \n  // ✅ Senha válida!\n  return [{\n    json: {\n      autenticado: true,\n      usuario: {\n        id: $json.id,\n        email: $json.email,\n        tenant_id: $json.tenant_id,\n        tenant_nome: $json.tenant_nome,\n        role: $json.role\n      }\n    }\n  }];\n  \n} catch (error) {\n  return [{\n    json: {\n      autenticado: false,\n      erro: 'ERRO_VALIDACAO',\n      mensagem: 'Erro ao validar senha',\n      detalhes: error.message\n    }\n  }];\n}\n"
      },
      "id": "f6be5641-c169-4891-8838-0bd7984f959d",
      "name": "Validar Senha",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        576
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.autenticado }}",
              "value2": true
            }
          ]
        }
      },
      "id": "0547cea7-809f-4944-8aac-0211968e1b25",
      "name": "Senha Válida?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1232,
        576
      ]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// GERAÇÃO DE TOKENS JWT (ACCESS + REFRESH)\n// ============================================\n\nconst crypto = require('crypto');\nconst { v4: uuidv4 } = require('uuid');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'YOUR_SECRET_KEY_CHANGE_ME';\n\nfunction base64UrlEncode(str) {\n  return Buffer.from(str)\n    .toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n}\n\nfunction createJwt(payload, secret) {\n  const header = { alg: 'HS256', typ: 'JWT' };\n  \n  const encodedHeader = base64UrlEncode(JSON.stringify(header));\n  const encodedPayload = base64UrlEncode(JSON.stringify(payload));\n  \n  const signature = crypto\n    .createHmac('sha256', secret)\n    .update(`${encodedHeader}.${encodedPayload}`)\n    .digest('base64url');\n  \n  return `${encodedHeader}.${encodedPayload}.${signature}`;\n}\n\nconst usuario = $json.usuario;\nconst now = Math.floor(Date.now() / 1000);\n\n// JTI únicos para cada token\nconst accessJti = uuidv4();\nconst refreshJti = uuidv4();\n\n// Access Token (15 minutos)\nconst accessPayload = {\n  sub: usuario.id,\n  email: usuario.email,\n  tenant_id: usuario.tenant_id,\n  role: usuario.role,\n  type: 'access',\n  jti: accessJti,\n  iat: now,\n  exp: now + (15 * 60) // 15 minutos\n};\n\n// Refresh Token (7 dias)\nconst refreshPayload = {\n  sub: usuario.id,\n  tenant_id: usuario.tenant_id,\n  type: 'refresh',\n  jti: refreshJti,\n  iat: now,\n  exp: now + (7 * 24 * 60 * 60) // 7 dias\n};\n\nconst accessToken = createJwt(accessPayload, JWT_SECRET);\nconst refreshToken = createJwt(refreshPayload, JWT_SECRET);\n\nreturn [{\n  json: {\n    usuario,\n    access_token: accessToken,\n    refresh_token: refreshToken,\n    access_jti: accessJti,\n    refresh_jti: refreshJti,\n    expires_in: 900, // 15 minutos em segundos\n    token_type: 'Bearer',\n    expires_at: new Date((now + 900) * 1000).toISOString(),\n    refresh_expires_at: new Date(refreshPayload.exp * 1000).toISOString()\n  }\n}];\n"
      },
      "id": "4885f047-46f4-4a33-8103-483b0432f0a0",
      "name": "Gerar Tokens JWT",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        560
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO public.user_sessions (\n  id,\n  user_id,\n  tenant_id,\n  access_token,\n  refresh_token,\n  access_jti,\n  refresh_jti,\n  expires_at,\n  refresh_expires_at,\n  ip_address,\n  user_agent,\n  revogado\n)\nVALUES (\n  gen_random_uuid(),\n  $1::uuid,\n  $2::uuid,\n  $3,\n  $4,\n  $5::uuid,\n  $6::uuid,\n  $7::timestamp,\n  $8::timestamp,\n  $9,\n  $10,\n  false\n)\nRETURNING id, created_at;",
        "options": {
          "queryReplacement": "={{ $json.usuario.id }}\n={{ $json.usuario.tenant_id }}\n={{ $json.access_token }}\n={{ $json.refresh_token }}\n={{ $json.access_jti }}\n={{ $json.refresh_jti }}\n={{ $json.expires_at }}\n={{ $json.refresh_expires_at }}\n={{ $items('Webhook Login')[0].json.headers['x-forwarded-for'] || $items('Webhook Login')[0].json.headers['x-real-ip'] || 'unknown' }}\n={{ $items('Webhook Login')[0].json.headers['user-agent'] || 'unknown' }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1648,
        560
      ],
      "id": "980e6735-037d-4608-a98c-3171d591568d",
      "name": "Criar Sessão",
      "credentials": {
        "postgres": {
          "id": "ISeq8ovLtFz7Vb1t",
          "name": "Postgres CredGestor"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO public.audit_log (\n  id,\n  tenant_id,\n  user_id,\n  acao,\n  tabela,\n  descricao,\n  ip_address,\n  user_agent\n)\nVALUES (\n  gen_random_uuid(),\n  $1::uuid,\n  $2::uuid,\n  'LOGIN',\n  'user_sessions',\n  'Login realizado com sucesso',\n  $3,\n  $4\n);",
        "options": {
          "queryReplacement": "={{ $('Gerar Tokens JWT').item.json.usuario.tenant_id }}\n={{ $('Gerar Tokens JWT').item.json.usuario.id }}\n={{ $items('Webhook Login')[0].json.headers['x-forwarded-for'] || $items('Webhook Login')[0].json.headers['x-real-ip'] || 'unknown' }}\n={{ $items('Webhook Login')[0].json.headers['user-agent'] || 'unknown' }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1840,
        560
      ],
      "id": "5fca99e4-064c-43c3-ae1f-159456e6dac6",
      "name": "Log Auditoria Login",
      "credentials": {
        "postgres": {
          "id": "ISeq8ovLtFz7Vb1t",
          "name": "Postgres CredGestor"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  sucesso: true,\n  access_token: $('Gerar Tokens JWT').item.json.access_token,\n  refresh_token: $('Gerar Tokens JWT').item.json.refresh_token,\n  token_type: 'Bearer',\n  expires_in: $('Gerar Tokens JWT').item.json.expires_in,\n  usuario: {\n    id: $('Gerar Tokens JWT').item.json.usuario.id,\n    email: $('Gerar Tokens JWT').item.json.usuario.email,\n    tenant_id: $('Gerar Tokens JWT').item.json.usuario.tenant_id,\n    tenant_nome: $('Gerar Tokens JWT').item.json.usuario.tenant_nome,\n    role: $('Gerar Tokens JWT').item.json.usuario.role\n  },\n  timestamp: new Date().toISOString()\n} }}",
        "options": {}
      },
      "id": "41b3dd00-17e8-4454-9025-82edd84c3ccf",
      "name": "Response Login Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2064,
        560
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "auth/refresh",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "9840ff08-0e00-410f-a49d-308caad5a685",
      "name": "Webhook Refresh Token",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -224,
        1264
      ],
      "webhookId": "auth-refresh"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// VALIDAÇÃO DE REFRESH TOKEN\n// ============================================\n\nconst crypto = require('crypto');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'YOUR_SECRET_KEY_CHANGE_ME';\n\nfunction base64UrlDecode(str) {\n  const pad = str.length % 4 === 0 ? '' : '='.repeat(4 - (str.length % 4));\n  const b64 = (str + pad).replace(/-/g, '+').replace(/_/g, '/');\n  return Buffer.from(b64, 'base64').toString('utf8');\n}\n\nfunction verifyJwtSignature(header, payload, signature, secret) {\n  const data = `${header}.${payload}`;\n  const expectedSignature = crypto\n    .createHmac('sha256', secret)\n    .update(data)\n    .digest('base64url');\n  return signature === expectedSignature;\n}\n\nconst body = $json.body || {};\nconst refreshToken = body.refresh_token;\n\nif (!refreshToken) {\n  return [{\n    json: {\n      valido: false,\n      erro: 'REFRESH_TOKEN_REQUIRED',\n      mensagem: 'refresh_token é obrigatório'\n    }\n  }];\n}\n\nconst parts = refreshToken.split('.');\nif (parts.length !== 3) {\n  return [{\n    json: {\n      valido: false,\n      erro: 'INVALID_TOKEN_FORMAT',\n      mensagem: 'Token mal formado'\n    }\n  }];\n}\n\nconst [headerB64, payloadB64, signatureB64] = parts;\n\nif (!verifyJwtSignature(headerB64, payloadB64, signatureB64, JWT_SECRET)) {\n  return [{\n    json: {\n      valido: false,\n      erro: 'INVALID_SIGNATURE',\n      mensagem: 'Assinatura inválida'\n    }\n  }];\n}\n\nlet payload;\ntry {\n  payload = JSON.parse(base64UrlDecode(payloadB64));\n} catch (e) {\n  return [{\n    json: {\n      valido: false,\n      erro: 'INVALID_PAYLOAD',\n      mensagem: 'Payload inválido'\n    }\n  }];\n}\n\nif (payload.exp && payload.exp * 1000 < Date.now()) {\n  return [{\n    json: {\n      valido: false,\n      erro: 'TOKEN_EXPIRED',\n      mensagem: 'Refresh token expirado'\n    }\n  }];\n}\n\nif (payload.type !== 'refresh') {\n  return [{\n    json: {\n      valido: false,\n      erro: 'INVALID_TOKEN_TYPE',\n      mensagem: 'Token não é do tipo refresh'\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    valido: true,\n    user_id: payload.sub,\n    tenant_id: payload.tenant_id,\n    refresh_jti: payload.jti,\n    refresh_token: refreshToken\n  }\n}];\n"
      },
      "id": "eea3a1f9-0e3b-4839-89bb-88d299b609b3",
      "name": "Validar Refresh Token",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -16,
        1264
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.valido }}",
              "value2": true
            }
          ]
        }
      },
      "id": "3fa2d04b-65cd-4206-89e7-4dd797a0c162",
      "name": "Refresh Token Válido?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        192,
        1264
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "d23a7364-a454-4a79-bed9-436e6b47f109",
      "name": "Response Refresh Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        400,
        1424
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  us.id,\n  us.user_id,\n  us.tenant_id,\n  us.refresh_jti,\n  us.revogado,\n  us.refresh_expires_at,\n  tu.email,\n  tu.role,\n  t.nome as tenant_nome\nFROM public.user_sessions us\nINNER JOIN public.tenant_users tu ON tu.id = us.user_id\nINNER JOIN public.tenants t ON t.id = us.tenant_id\nWHERE us.refresh_jti = $1::uuid\n  AND us.user_id = $2::uuid\n  AND us.tenant_id = $3::uuid\n  AND us.revogado = false\n  AND us.refresh_expires_at > NOW()\nLIMIT 1;",
        "options": {
          "queryReplacement": "={{ $json.refresh_jti }}\n={{ $json.user_id }}\n={{ $json.tenant_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        400,
        1184
      ],
      "id": "c1488702-5096-43ed-b578-c103c122621c",
      "name": "Verificar Sessão Refresh",
      "credentials": {
        "postgres": {
          "id": "ISeq8ovLtFz7Vb1t",
          "name": "Postgres CredGestor"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $items().length }}",
              "operation": "larger"
            }
          ]
        }
      },
      "id": "ce104c43-eb20-4f91-bfdf-1c185e8bc011",
      "name": "Sessão Refresh Válida?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        608,
        1184
      ]
    },
    {
      "parameters": {
        "jsCode": "// Gerar novos tokens usando a mesma lógica\nconst crypto = require('crypto');\nconst { v4: uuidv4 } = require('uuid');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'YOUR_SECRET_KEY_CHANGE_ME';\n\nfunction base64UrlEncode(str) {\n  return Buffer.from(str)\n    .toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n}\n\nfunction createJwt(payload, secret) {\n  const header = { alg: 'HS256', typ: 'JWT' };\n  const encodedHeader = base64UrlEncode(JSON.stringify(header));\n  const encodedPayload = base64UrlEncode(JSON.stringify(payload));\n  const signature = crypto\n    .createHmac('sha256', secret)\n    .update(`${encodedHeader}.${encodedPayload}`)\n    .digest('base64url');\n  return `${encodedHeader}.${encodedPayload}.${signature}`;\n}\n\nconst now = Math.floor(Date.now() / 1000);\nconst accessJti = uuidv4();\nconst refreshJti = uuidv4();\n\nconst accessPayload = {\n  sub: $json.user_id,\n  email: $json.email,\n  tenant_id: $json.tenant_id,\n  role: $json.role,\n  type: 'access',\n  jti: accessJti,\n  iat: now,\n  exp: now + (15 * 60)\n};\n\nconst refreshPayload = {\n  sub: $json.user_id,\n  tenant_id: $json.tenant_id,\n  type: 'refresh',\n  jti: refreshJti,\n  iat: now,\n  exp: now + (7 * 24 * 60 * 60)\n};\n\nconst accessToken = createJwt(accessPayload, JWT_SECRET);\nconst refreshToken = createJwt(refreshPayload, JWT_SECRET);\n\nreturn [{\n  json: {\n    session_id: $json.id,\n    old_refresh_jti: $json.refresh_jti,\n    usuario: {\n      id: $json.user_id,\n      email: $json.email,\n      tenant_id: $json.tenant_id,\n      tenant_nome: $json.tenant_nome,\n      role: $json.role\n    },\n    access_token: accessToken,\n    refresh_token: refreshToken,\n    access_jti: accessJti,\n    refresh_jti: refreshJti,\n    expires_in: 900,\n    token_type: 'Bearer',\n    expires_at: new Date((now + 900) * 1000).toISOString(),\n    refresh_expires_at: new Date(refreshPayload.exp * 1000).toISOString()\n  }\n}];\n"
      },
      "id": "f34e0dde-3591-4541-b556-9a4d9a8db538",
      "name": "Gerar Novos Tokens",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        832,
        1168
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Revogar sessão antiga\nUPDATE public.user_sessions\nSET revogado = true,\n    revogado_em = NOW(),\n    revogado_motivo = 'Token renovado'\nWHERE id = $1::uuid;\n\n-- Criar nova sessão\nINSERT INTO public.user_sessions (\n  id,\n  user_id,\n  tenant_id,\n  access_token,\n  refresh_token,\n  access_jti,\n  refresh_jti,\n  expires_at,\n  refresh_expires_at,\n  ip_address,\n  user_agent,\n  revogado\n)\nVALUES (\n  gen_random_uuid(),\n  $2::uuid,\n  $3::uuid,\n  $4,\n  $5,\n  $6::uuid,\n  $7::uuid,\n  $8::timestamp,\n  $9::timestamp,\n  $10,\n  $11,\n  false\n)\nRETURNING id, created_at;",
        "options": {
          "queryReplacement": "={{ $json.session_id }}\n={{ $json.usuario.id }}\n={{ $json.usuario.tenant_id }}\n={{ $json.access_token }}\n={{ $json.refresh_token }}\n={{ $json.access_jti }}\n={{ $json.refresh_jti }}\n={{ $json.expires_at }}\n={{ $json.refresh_expires_at }}\n={{ $items('Webhook Refresh Token')[0].json.headers['x-forwarded-for'] || 'unknown' }}\n={{ $items('Webhook Refresh Token')[0].json.headers['user-agent'] || 'unknown' }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1008,
        1168
      ],
      "id": "c415862c-c090-47ca-9620-b10732f6495c",
      "name": "Atualizar Sessão",
      "credentials": {
        "postgres": {
          "id": "ISeq8ovLtFz7Vb1t",
          "name": "Postgres CredGestor"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  sucesso: true,\n  access_token: $('Gerar Novos Tokens').item.json.access_token,\n  refresh_token: $('Gerar Novos Tokens').item.json.refresh_token,\n  token_type: 'Bearer',\n  expires_in: $('Gerar Novos Tokens').item.json.expires_in,\n  timestamp: new Date().toISOString()\n} }}",
        "options": {}
      },
      "id": "0d7d2805-e7e1-4067-97c2-3fc0ce8ab894",
      "name": "Response Refresh Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1232,
        1168
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "auth/logout",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "2f3de60c-6a52-4714-a1ee-1719b71b8272",
      "name": "Webhook Logout",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -112,
        1968
      ],
      "webhookId": "auth-logout"
    },
    {
      "parameters": {
        "jsCode": "// Reutilizar middleware de validação\nconst crypto = require('crypto');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'YOUR_SECRET_KEY_CHANGE_ME';\n\nfunction getAuthHeader(headers) {\n  if (!headers) return '';\n  return headers.authorization || headers.Authorization || '';\n}\n\nfunction base64UrlDecode(str) {\n  const pad = str.length % 4 === 0 ? '' : '='.repeat(4 - (str.length % 4));\n  const b64 = (str + pad).replace(/-/g, '+').replace(/_/g, '/');\n  return Buffer.from(b64, 'base64').toString('utf8');\n}\n\nfunction verifyJwtSignature(header, payload, signature, secret) {\n  const data = `${header}.${payload}`;\n  const expectedSignature = crypto\n    .createHmac('sha256', secret)\n    .update(data)\n    .digest('base64url');\n  return signature === expectedSignature;\n}\n\nconst headers = $json.headers || {};\nconst authHeader = getAuthHeader(headers);\n\nif (!authHeader || !authHeader.startsWith('Bearer ')) {\n  return [{ json: { valido: false, erro: 'TOKEN_NAO_FORNECIDO' } }];\n}\n\nconst token = authHeader.slice(7).trim();\nconst parts = token.split('.');\n\nif (parts.length !== 3) {\n  return [{ json: { valido: false, erro: 'TOKEN_INVALIDO' } }];\n}\n\nconst [headerB64, payloadB64, signatureB64] = parts;\n\nif (!verifyJwtSignature(headerB64, payloadB64, signatureB64, JWT_SECRET)) {\n  return [{ json: { valido: false, erro: 'ASSINATURA_INVALIDA' } }];\n}\n\nlet payload;\ntry {\n  payload = JSON.parse(base64UrlDecode(payloadB64));\n} catch (e) {\n  return [{ json: { valido: false, erro: 'PAYLOAD_INVALIDO' } }];\n}\n\nreturn [{\n  json: {\n    valido: true,\n    user_id: payload.sub,\n    tenant_id: payload.tenant_id,\n    jti: payload.jti\n  }\n}];\n"
      },
      "id": "7c0225e2-3f12-40a2-a22a-66c0ab94a0f8",
      "name": "Validar Token Logout",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        96,
        1968
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.valido }}",
              "value2": true
            }
          ]
        }
      },
      "id": "c973c772-7394-4012-bb1a-5e1a97c21214",
      "name": "Token Logout Válido?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        304,
        1968
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE public.user_sessions\nSET revogado = true,\n    revogado_em = NOW(),\n    revogado_motivo = 'Logout do usuário'\nWHERE (access_jti = $1::uuid OR refresh_jti = $1::uuid)\n  AND user_id = $2::uuid\n  AND tenant_id = $3::uuid\n  AND revogado = false;",
        "options": {
          "queryReplacement": "={{ $json.jti }}\n={{ $json.user_id }}\n={{ $json.tenant_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        512,
        1888
      ],
      "id": "44088d7d-93c1-4e1a-8391-908ce144efaf",
      "name": "Revogar Sessão",
      "credentials": {
        "postgres": {
          "id": "ISeq8ovLtFz7Vb1t",
          "name": "Postgres CredGestor"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  sucesso: true,\n  mensagem: 'Logout realizado com sucesso',\n  timestamp: new Date().toISOString()\n} }}",
        "options": {}
      },
      "id": "79ef00a8-f5ef-4520-81eb-60cfe9e879b4",
      "name": "Response Logout Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        720,
        1888
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  erro: 'TOKEN_INVALIDO',\n  mensagem: 'Token inválido ou não fornecido',\n  timestamp: new Date().toISOString()\n} }}",
        "options": {}
      },
      "id": "70615581-c6b7-4c5d-845c-44038a804da1",
      "name": "Response Logout Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        512,
        2128
      ]
    }
  ],
  "pinData": {},
  "repo_name": "backup-n8n",
  "repo_owner": "faelsou",
  "repo_path": "backups",
  "settings": {
    "executionOrder": "v1"
  },
  "shared": [
    {
      "createdAt": "2025-12-29T15:18:45.244Z",
      "updatedAt": "2025-12-29T15:18:45.244Z",
      "role": "workflow:owner",
      "workflowId": "cWHEh80Mq8M2fRqm",
      "projectId": "uxvBhUmI1Fx6jdU7"
    }
  ],
  "staticData": null,
  "tags": [],
  "triggerCount": 4,
  "updatedAt": "2025-12-29T17:35:33.672Z",
  "versionId": "d9264d58-dda6-44a8-aadf-ef6ed5c37e54"
}